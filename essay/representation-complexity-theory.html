<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>言語の表現力理論</title>
  <!--# include file="/~egi/templates/header.html" -->
</head>

<body>

<h1>言語の表現力理論</h1>

<h2>概要</h2>

<ol>
<li>プログラムの読解にかかる時間的コストは，プログラムのワード数とする．</li>
<li><b>プログラムの読解にかかる空間的コストは，読解するために覚えておかなければならない名前の数とする．</b></li>
<li>できるだけ多くの種類のプログラムにたいする読解コストからでは，ある言語の表現力を測る．</li>
</ol>

<h2>イントロダクション</h2>

<p>
ある対象を表現するベストな表記方法は，その対象に対する我々の理解が深まるにつれて変わっていく．
</p>

<p>
例えば，数のベストな表記方法は，四則演算の知識をどれだけ持っているかに依存する．
たし算やかけ算の概念とそれらの性質をある程度知っていひとには，10進表記法はベストな数の表記である．
しかし，たし算もかけ算も知らないひとにとってはこの表記は理解不能である．
単純に数の分だけ棒を並べるような表記がこのような場合にはベストな表記となる．
また，たし算の概念は知っているけれども，かけ算までは知らないひとにはローマ数字のような表記がベストとなる．
</p>

<p>
テンソル計算のベストな表記方法も，テンソルとテンソル演算についての知識をどれだけもっているかに依存する．
RicciとLevi-Civitaによって開発されたテンソルの添字記法は，微分幾何や一般相対性理論の発展に大きな寄与をした記法である．
この，テンソルの添字記法を理解するには，まず，ベクトル，行列を一般化した概念であるテンソルを理解しておく必要がある．
さらに，反変・共変の概念を理解し，テンソル積，アダマール積，内積が，テンソルについての演算の基本的な構成要素であることを知っておく必要がある．
その上に，上下添字という2種類の添字のアイデアとシンボリックな添字を並べるというアイデアがあれば，添字記法は実現する．
</p>

<p>
以上の議論は，よりよい数式表記の話に一般化される．
数式表記の進化は，科学知識の発展と表裏一体の関係にある．
</p>

<p>
人類が数学を始めたばかりの頃，アルゴリズムを記述を始めたばかりの頃は，アルゴリズムは自然言語のみで記述されていた．
数学が発展していくにつれて，よく現れる計算については，数式という形でより簡潔に表現されるようになった．
数式が発明された後からは，アルゴリズムは自然言語と数式を組み合わせて記述されるようになった．
アルゴリズムの記述の中で，自然言語に対する数式の割合は，長い時間をかけて，少しずつ増えていった．
</p>

<p>
数式は，自然言語にくらべると，簡潔であるだけでなく，より形式的でもある．
つまり，数式は自然言語にくらべて，読み手による適切な補完を必要なしに解釈できるようになっている．
表現が形式的であることは，コンピューターサイエンスにおいては非常に重要である．
コンピューターは，形式的な表現しか理解できないからである．
</p>

<p>
コンピューターの出現によって，アルゴリズムの記述の形式化が一気に押し進められた．
今まで自然言語で記述されていた事柄もすべてプログラミング言語により形式的に表現されるようになった．
その過程で，静的スコープや，高階関数，パターンマッチなどといったプログラミング言語独自の新しい表現の工夫が生まれた．
</p>

<p>
本研究は，このような新しい表現の工夫の効果を形式的に測る手法を提案するものである．
</p>

<h2>説明</h2>

<p>
アルゴリズムの効率を測るために，我々は計算量という概念を使う．
計算量は，計算にかかる時間的コストを測る時間的計算量と，計算にかかる空間的コストを測る空間的計算量がある．
</p>

<p>
我々は，プログラミング言語の表現力を測るためのこれらの概念に似た概念を提案する．
この提案では，ある言語の表現力を，その言語によるアルゴリズムの記述を読解するための時間的コストと空間的コストで測る．
</p>

<p>
ある言語によるアルゴリズムの記述を読解するための時間的コストと空間的コストとは，具体的に何であるのかが，ここで問題となる．
本提案では，プログラムの読解にかかる時間的コストは，プログラムのワード数とする．
また，プログラムの読解にかかる空間的コストは，読解するために覚えておかなければならない名前の数とする．
</p>

<p>
またここで，単一のプログラムにたいする読解コストだけからでは，ある言語の表現力を測ることはできないということを注意しておく．
理想的には，人類が発見しうるすべてのアルゴリズムにたいする読解コストの合計を測りたい．
現在発見されたすべてのアルゴリズムにたいする読解コストの合計でもよいが，これでも現実的ではない．
できるだけ多くの複数のアルゴリズムにたいする読解コストの合計を測るのが現実的であろう．
</p>

<p>
例をあげて上記の主張の正当性を考えてみよう．
</p>

<p>
まず，もっとも簡単な例として，数の表記について考えてみよう．
単純に棒を並べるだけの表記と10進表記の違いについて考えてみる．
棒を並べる表記で123という数を表すと，123本の棒を並べる必要がある．
これを読解するのにかかる時間的コストは123である．
対して，10進表記では，3個の数字を並べるだけで表現できる．
これを読解するのにかかる時間的コストは3である．
</p>

<p>
上の例では，123という1つの数について考えた．
しかし，すべての数についてそれぞれの表記法の読解コストを考えることは重要である．
例えば，1や2のような小さい数について考えただけでは，2つの表記法の差異はほとんどない．
また，漢字による数の表記のように，ある特定のパターンに属する数だけ少ない読解コストの記述ができる表記法もある．
例えば，20000は10進表記では5個の文字が必要であるが，漢字による表記では，二万と2個の文字で書ける．
</p>

<p>
次に，2進表記と10進表記の違いについても考えてみよう．
2進法と10進法は本質的に同じ表現であるが，この例に，読解にかかる時間的コストと空間的コストがトレードオフの関係にもあることをみることができる．
例えば，2進数で1000を表記した場合，10つの文字が必要で，読解にかかる時間的コストは10と考えることができる．
対して，10進数で1000を表記した場合，4つの文字が必要で，読解にかかる時間的コストは4と考えることができる．
読解に必要な空間的コストについては，2進数の場合は，0と1の2個の文字だけ知っていればいいのに対して，10進数の場合は，0-9の10個の文字を知っている必要がある．
</p>

<p>
読解に必要な時間的・空間的コストは，その言語を学ぶのに必要な学習コストも含まなければならない．
言語の組み込み構文や，ライブラリ関数について，それぞれの構文や関数を覚えておくのに必要な空間的コストは定数であり1としてよい．
また，これらを学習するための時間的コストについても定数であり1としてよいことにする．
</p>

<p>
あらゆるアルゴリズムを関数としてライブラリにもっている言語を考えよう．
そのような言語はどのようなアルゴリズムを記述するにも無限の時間的・空間的コストを必要とする．
そのため，このような特殊な言語はよい言語たりえない．
</p>

<p>
アルゴリズムを読解するために一時的に覚えておかなければならない名前が，上記の言語の学習のためのコストと共に，プログラム読解のための空間的コストを構成する．
例えば，動的スコープを持つ言語と静的スコープを持つ言語では，プログラムを読解するのに一時的に覚えておかなければならないワード数が大きく異る．
そのため，本提案手法で，静的スコープを持つ言語は動的スコープを持つ言語よりもよい言語であるという結果を得ることができる．
</p>

<p>
ある新しい構文の性能を測るためには，アルゴリズム全体のなかである程度より大きな量のアルゴリズムが，その構文により，少ない読解コストの記述ができるようになることを示せば良い．
例えば，静的スコープの有効性に納得するのは簡単である．
なぜなら，ほとんどすべてのアルゴリズムを記すのに，関数によるモジュール化は重要であるからである．
すでに発見されているアルゴリズムを記述するのにおいても，とても有用な構文もあるであろうし，まだ発見されていないアルゴリズムにおいて，とても有用な構文もあるであろう．
</p>

<p>
他の例として，関数型言語のパターンマッチについて考えてみる．
パターンマッチをリストにたいして使った場合，我々は大量のcarとcdrをプログラム中で書く必要がなくなる．
これは，プログラムのワード数を減らす．
そのため，プログラム読解の時間的コストの削減にパターンマッチは貢献する．
また，我々は，いろいろなデータ構造にたいしてそれぞれアクセサー関数を定義する必要もなくなる．
これは，プログラム読解のために覚えなければならない変数の数を減らす．
つまり，プログラム読解の空間的コストの削減にパターンマッチは貢献する．
</p>

<hr/>

<p>
図. 高階関数が，読解のための時間的コストと空間的コストの両方を削減しているプログラムの例．
</p>

<pre>
<code>
(map (lambda [$x] (+ x 1)) xs)
</code>
</pre>

<pre>
<code>
m = length(xs)
i = 0
while (i < m) {
  ys[i] = xs[i] + 1
  i = i + 1
}
</code>
</pre>

<p>
図. 代数的データ型にたいするパターンマッチが，読解のための時間的コストと空間的コストの両方を削減しているプログラムの例．
</p>

<pre>
<code>
reverse [] = []
reverse (x:xs) = (reverse xs) ++ [x]
</code>
</pre>

<pre>
<code>
reverse xs =
  if xs == []
    then []
    else (reverse (tail xs)) ++ [head xs]
</code>
</pre>
